{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Refactor FormBuilder.tsx to Adhere to SRP",
        "description": "The `FormBuilder.tsx` component currently violates the Single Responsibility Principle by managing state, drag and drop logic, and conditional rendering. This task is to refactor it by extracting the drag and drop functionality.",
        "details": "1. Create a new component, `DraggableFormBuilder.tsx`, in `src/components/FormBuilder/`. 2. Move all `dnd-kit` related logic, including `DndContext`, `DragOverlay`, and event handlers (`handleDragStart`, `handleDragEnd`, etc.), from `FormBuilder.tsx` to `DraggableFormBuilder.tsx`. 3. `DraggableFormBuilder` should wrap the `FormBuilder` component, providing the drag and drop context. 4. Simplify `FormBuilder.tsx` to only be responsible for rendering `BuilderCanvas` or `JsonEditor` based on props. It should no longer contain direct drag and drop logic.",
        "testStrategy": "Verify that drag and drop functionality for reordering widgets works as before. Update existing tests for `FormBuilder.tsx` to reflect its new role as a presentational component. Create new unit tests for `DraggableFormBuilder.tsx` to cover the extracted drag and drop logic.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DraggableFormBuilder.tsx and Define Component Structure",
            "description": "Create the new file for the drag-and-drop wrapper component and set up its basic structure. This component will eventually house all the logic related to dnd-kit.",
            "dependencies": [],
            "details": "In the `src/components/FormBuilder/` directory, create a new file named `DraggableFormBuilder.tsx`. Inside this file, define a new React functional component `DraggableFormBuilder`. For now, it should just render its children. This sets up the foundation for moving the D&D logic.",
            "status": "pending",
            "testStrategy": "Verify the new file `DraggableFormBuilder.tsx` is created in the correct directory and contains a basic, empty React component."
          },
          {
            "id": 2,
            "title": "Move DndContext, DragOverlay, and Related State to DraggableFormBuilder",
            "description": "Extract the core dnd-kit components and the state that tracks the active dragged item from `FormBuilder.tsx` into the new `DraggableFormBuilder.tsx`.",
            "dependencies": [],
            "details": "Cut the `DndContext` and `DragOverlay` components from `FormBuilder.tsx`. Paste them into `DraggableFormBuilder.tsx` so they wrap the rendered children. Also, move the `activeWidget` state (`useState<Widget | null>`) and all related type and library imports from `@dnd-kit/core` from `FormBuilder.tsx` to `DraggableFormBuilder.tsx`.",
            "status": "pending",
            "testStrategy": "Review the diff for both files to ensure the components and state have been moved correctly and that `DraggableFormBuilder.tsx` now contains the D&D context wrappers."
          },
          {
            "id": 3,
            "title": "Relocate Drag and Drop Event Handlers and Hook Usage",
            "description": "Move the drag-and-drop event handling functions (`handleDragStart`, `handleDragOver`, `handleDragEnd`) from `FormBuilder.tsx` to `DraggableFormBuilder.tsx`.",
            "dependencies": [],
            "details": "Cut the `handleDragStart`, `handleDragOver`, and `handleDragEnd` functions from `FormBuilder.tsx` and paste them into `DraggableFormBuilder.tsx`. Since these handlers depend on state manipulation functions from the `useFormBuilder` hook, ensure `DraggableFormBuilder.tsx` calls `useFormBuilder()` to get access to them. Wire up the `onDragStart`, `onDragOver`, and `onDragEnd` props of the `DndContext` to these handlers.",
            "status": "pending",
            "testStrategy": "Ensure `DraggableFormBuilder.tsx` now contains the drag event handlers and calls the `useFormBuilder` hook. Verify the `DndContext` props are correctly assigned."
          },
          {
            "id": 4,
            "title": "Simplify FormBuilder.tsx to a Presentational Component",
            "description": "Refactor `FormBuilder.tsx` to remove all the drag-and-drop logic that has been moved, simplifying it to a component that only handles conditional rendering.",
            "dependencies": [],
            "details": "In `FormBuilder.tsx`, remove all `dnd-kit` imports, the `activeWidget` state, and the `handleDrag...` event handlers. The component's `return` statement should no longer include `DndContext` or `DragOverlay`. Its sole responsibility is now to use the `view` state from the `useFormBuilder` hook to render either `<BuilderCanvas />` or `<JsonEditor />`.",
            "status": "pending",
            "testStrategy": "Inspect `FormBuilder.tsx` to confirm it no longer contains any direct `dnd-kit` logic. Run existing tests for `FormBuilder.tsx` and update them to reflect its new, simpler role."
          },
          {
            "id": 5,
            "title": "Integrate DraggableFormBuilder and Update Parent Component",
            "description": "Finalize the refactoring by making `DraggableFormBuilder` render the simplified `FormBuilder` and updating the parent component to use the new wrapper.",
            "dependencies": [],
            "details": "Modify `DraggableFormBuilder.tsx` to render `<FormBuilder />` inside its `DndContext`. Then, use the Grep tool to find where `<FormBuilder />` is used in the application (e.g., a page component). Replace that usage with the new `<DraggableFormBuilder />` component. This ensures the drag-and-drop context is correctly provided to the form builder UI.",
            "status": "pending",
            "testStrategy": "Manually test the form builder page to verify that all drag-and-drop functionalities (reordering, adding new widgets) work exactly as they did before the refactor. Create a new unit test for `DraggableFormBuilder.tsx` to cover the D&D logic."
          }
        ]
      },
      {
        "id": 2,
        "title": "Refactor workflow-canvas.tsx to Separate Concerns",
        "description": "The `workflow-canvas.tsx` component is a 'god component' handling state, drag and drop, node/edge logic, and rendering. This task is to break it down into smaller, more manageable parts.",
        "details": "1. Create a new custom hook `useWorkflowState.ts` in `src/hooks/`. This hook should encapsulate `useNodesState`, `useEdgesState`, and all logic for adding, deleting, and connecting nodes/edges. 2. Move the initial nodes and edges data to a new file: `src/data/workflow-initial-data.ts`. 3. Refactor `WorkflowCanvas` to be a pure presentational component. It should receive nodes, edges, and event handlers from props (provided by a container or parent component using the new `useWorkflowState` hook). 4. The `WorkflowCanvas` should primarily render the `ReactFlow` component with its UI elements like `Background`, `Controls`, and `MiniMap`.",
        "testStrategy": "Create unit tests for the new `useWorkflowState` hook to ensure node/edge manipulation logic is correct. Update tests for `WorkflowCanvas` to verify it renders correctly based on props. Perform manual regression testing to ensure the entire workflow canvas functionality (adding nodes, connecting, etc.) is intact.",
        "priority": "high",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Extract Initial Node and Edge Data",
            "description": "Create a new file to store the initial data for the workflow canvas, separating static data from component logic.",
            "dependencies": [],
            "details": "Create a new file at `src/data/workflow-initial-data.ts`. Cut the `initialNodes` and `initialEdges` constant definitions from `src/pages/Workflow/components/workflow-canvas.tsx` and paste them into this new file. Export both constants from `workflow-initial-data.ts`.",
            "status": "pending",
            "testStrategy": "Verify that the new data file exports the `initialNodes` and `initialEdges` arrays correctly."
          },
          {
            "id": 2,
            "title": "Create `useWorkflowState` Hook with State Initialization",
            "description": "Create the custom hook `useWorkflowState` and move the core React Flow state management into it.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a new file at `src/hooks/useWorkflowState.ts`. Inside this new hook, import `useNodesState` and `useEdgesState` from 'reactflow', and import `initialNodes` and `initialEdges` from `src/data/workflow-initial-data.ts`. Use these hooks with the initial data to manage `nodes` and `edges` state. The hook should return `nodes`, `setNodes`, `onNodesChange`, `edges`, `setEdges`, and `onEdgesChange`.",
            "status": "pending",
            "testStrategy": "Create a basic unit test for the hook to ensure it initializes with the correct number of nodes and edges."
          },
          {
            "id": 3,
            "title": "Migrate All Interaction Logic to `useWorkflowState` Hook",
            "description": "Move all event handlers and business logic related to the workflow canvas from the component into the new custom hook.",
            "dependencies": [
              "2.2"
            ],
            "details": "Move the logic for `onConnect`, `onDragOver`, `onDrop`, `onNodeDragStop`, and the `getId` helper function from `workflow-canvas.tsx` into `useWorkflowState.ts`. Also, move the `reactFlowWrapper` ref and the `reactFlowInstance` state management into the hook. The hook should now also return these handlers (`onConnect`, `onDrop`, etc.), the `reactFlowWrapper` ref, and the `onInit` function for setting the React Flow instance.",
            "status": "pending",
            "testStrategy": "Write unit tests for the hook's returned functions, such as `onConnect`, to verify they correctly modify the nodes and edges state."
          },
          {
            "id": 4,
            "title": "Refactor `WorkflowCanvas` to a Presentational Component",
            "description": "Simplify the `WorkflowCanvas` component to be a pure presentational component that receives all its data and handlers via props.",
            "dependencies": [
              "2.3"
            ],
            "details": "Modify `src/pages/Workflow/components/workflow-canvas.tsx`. Remove all state and logic that was moved to the `useWorkflowState` hook. Update the component to accept props for `nodes`, `edges`, `onNodesChange`, `onEdgesChange`, `onConnect`, `onDrop`, `onDragOver`, `onInit`, and the `reactFlowWrapper` ref. Pass these props directly to the `ReactFlow` component and its wrapper div.",
            "status": "pending",
            "testStrategy": "Update or create snapshot tests for `WorkflowCanvas` to ensure it renders correctly based on a set of mock props."
          },
          {
            "id": 5,
            "title": "Integrate `useWorkflowState` Hook in Parent Component",
            "description": "Use the new hook in the parent component that renders `WorkflowCanvas` to provide the required props, completing the refactor.",
            "dependencies": [
              "2.4"
            ],
            "details": "Identify the parent component that renders `<WorkflowCanvas />` (likely `src/pages/Workflow/workflow-layout.tsx`). Import and call the `useWorkflowState` hook within this parent component. Pass the state, refs, and handlers returned from the hook as props to the `<WorkflowCanvas />` component.",
            "status": "pending",
            "testStrategy": "Perform manual end-to-end testing on the workflow page to ensure all functionality (adding nodes via drag-and-drop, connecting nodes, moving nodes) works exactly as it did before the refactor."
          }
        ]
      },
      {
        "id": 3,
        "title": "Simplify nodes-page.tsx using a Custom Hook",
        "description": "`nodes-page.tsx` mixes state management, data fetching, UI logic, and navigation. This task is to extract this logic into a custom hook to make the component presentational.",
        "details": "1. Create a new custom hook `useNodesPage.ts` in `src/hooks/`. 2. Move all logic from `nodes-page.tsx` into this hook, including: state from `useNodesStore` and `useUIStore`, the `loadNodes` data fetching effect, delete confirmation dialog state and handlers, and `useRouter` navigation logic. 3. The hook should return the necessary state (nodes, dialog open status) and handlers (delete handler, navigation functions). 4. Refactor `NodesPage` to be a pure presentational component that calls the `useNodesPage` hook and uses its return values to render the `NodesList` and delete confirmation dialog.",
        "testStrategy": "Create unit tests for the `useNodesPage` hook to verify data fetching, state management, and handler logic. Update the tests for `NodesPage` to ensure it renders correctly based on the data provided by the hook. Manually test the full user flow: viewing nodes, opening the delete dialog, confirming deletion, and navigation.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useNodesPage.ts` hook file and initial structure",
            "description": "Create the new file for the custom hook in the `src/hooks` directory and set up the basic function definition.",
            "dependencies": [],
            "details": "Create a new file at `src/hooks/useNodesPage.ts`. Inside this file, define and export an empty function named `useNodesPage`. This function will serve as the container for the logic to be extracted from `nodes-page.tsx`.",
            "status": "pending",
            "testStrategy": "Verify that the file `src/hooks/useNodesPage.ts` is created and exports a function named `useNodesPage`."
          },
          {
            "id": 2,
            "title": "Migrate state management and data fetching logic to `useNodesPage.ts`",
            "description": "Move all state-related hooks and the data fetching effect from `nodes-page.tsx` into the new `useNodesPage` hook.",
            "dependencies": [
              "3.1"
            ],
            "details": "Cut the following hooks and logic from `nodes-page.tsx` and paste them into the `useNodesPage` function: the `useRouter` call, the `useNodesStore` call, the `useUIStore` call, the `useState` calls for `nodeToDelete` and `isDeleteDialogOpen`, and the `useEffect` responsible for calling `loadNodes`. Ensure all necessary imports (`useEffect`, `useState`, `useRouter`, stores, types) are added to `useNodesPage.ts`.",
            "status": "pending",
            "testStrategy": "The hook should not have any linter errors regarding missing imports. The `nodes-page.tsx` component will be broken at this stage, which is expected."
          },
          {
            "id": 3,
            "title": "Migrate event handlers and navigation logic to `useNodesPage.ts`",
            "description": "Move all event handler functions and navigation logic from `nodes-page.tsx` into the `useNodesPage` hook.",
            "dependencies": [
              "3.2"
            ],
            "details": "Move the functions `handleDeleteClick`, `handleConfirmDelete`, `handleCancelDelete`, `handleEdit`, and `handleView` into `useNodesPage.ts`. Create a new handler, `handleCreateNode`, to encapsulate the `router.push('/nodes/create')` logic. These handlers should now use the state and setters defined within the hook itself.",
            "status": "pending",
            "testStrategy": "Verify that the handlers within the hook correctly reference the state and functions (e.g., `setNodeToDelete`, `router.push`) also located within the hook."
          },
          {
            "id": 4,
            "title": "Define the hook's return value and refactor `NodesPage` to use it",
            "description": "Expose the necessary state and handlers from the `useNodesPage` hook and refactor the `NodesPage` component to be a simple consumer of this hook.",
            "dependencies": [
              "3.3"
            ],
            "details": "In `useNodesPage.ts`, return an object containing all the state and handlers needed by the UI: `nodes`, `isDeleteDialogOpen`, `nodeToDelete`, `handleCreateNode`, `handleDeleteClick`, `handleConfirmDelete`, `handleCancelDelete`, `handleEdit`, and `handleView`. In `nodes-page.tsx`, remove all the extracted logic and replace it with a single call: `const { ... } = useNodesPage();`. The component should now be purely presentational.",
            "status": "pending",
            "testStrategy": "In `nodes-page.tsx`, verify that the component's body is significantly smaller and primarily consists of the hook call and the JSX return statement."
          },
          {
            "id": 5,
            "title": "Update child component props and cleanup `nodes-page.tsx`",
            "description": "Connect the values from the `useNodesPage` hook to the child components (`NodesList`, `ConfirmationDialog`) and remove all now-unused imports from `nodes-page.tsx`.",
            "dependencies": [
              "3.4"
            ],
            "details": "In `nodes-page.tsx`, update the props passed to `<Button>`, `<NodesList />`, and `<ConfirmationDialog />` to use the corresponding handlers and state from the `useNodesPage` hook. For example, the `onClick` for the 'Create Node' button should be `handleCreateNode`, and the `onDelete` prop for `NodesList` should be `handleDeleteClick`. Finally, remove all unused imports like `useEffect`, `useState`, `useRouter`, `useNodesStore`, etc., from `nodes-page.tsx`.",
            "status": "pending",
            "testStrategy": "Manually test the Nodes page functionality: verify that the node list loads, the 'Create Node' button navigates correctly, and the delete/edit/view actions on the list work as before the refactor."
          }
        ]
      },
      {
        "id": 4,
        "title": "Separate Data Fetching in workflow-page.tsx",
        "description": "`workflow-page.tsx` is responsible for both fetching workflow data and rendering the list. This task is to separate these concerns by introducing a container component.",
        "details": "1. Create a new container component, e.g., `WorkflowPageContainer.tsx`. 2. Move the data fetching logic (`loadTWorkflows` effect) and state management (`useWorkflowStore`) from `workflow-page.tsx` to `WorkflowPageContainer.tsx`. 3. `WorkflowPageContainer.tsx` will fetch the data and then render the `WorkflowPage` component, passing the workflows list as a prop. 4. Simplify `workflow-page.tsx` to be a pure presentational component that receives the `workflows` array as a prop and renders the `WorkflowList` component.",
        "testStrategy": "Test the `WorkflowPageContainer` to ensure it fetches data correctly on mount. Test the `WorkflowPage` component to ensure it renders the `WorkflowList` correctly given a list of workflows. Perform regression testing to confirm the workflow page still loads and displays data as expected.",
        "priority": "low",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Presentational Component `WorkflowPage.tsx`",
            "description": "Create a new pure presentational component that will be responsible for rendering the workflow page UI.",
            "dependencies": [],
            "details": "Create a new file at `src/components/workflows/WorkflowPage.tsx`. Define a functional component named `WorkflowPage` that accepts a `workflows` array as a prop. Move the entire JSX structure from the return statement of the existing `src/app/(pages)/workflows/page.tsx` into this new component. Define a `WorkflowPageProps` interface for the component's props, specifying `workflows: TWorkflow[]`. Ensure the component passes the received `workflows` prop to the `WorkflowList` component.",
            "status": "pending",
            "testStrategy": "Use Storybook to render the component with mock workflow data to verify it displays correctly."
          },
          {
            "id": 2,
            "title": "Create Container Component `WorkflowPageContainer.tsx`",
            "description": "Create a new container component to encapsulate data fetching and state management logic.",
            "dependencies": [],
            "details": "Create a new file at `src/components/workflows/WorkflowPageContainer.tsx`. Add the `'use client';` directive. Move the `useWorkflowStore` hook call and the `useEffect` hook (which calls `loadTWorkflows`) from `src/app/(pages)/workflows/page.tsx` into this new `WorkflowPageContainer` component.",
            "status": "pending",
            "testStrategy": "Write a unit test using React Testing Library to verify that the `loadTWorkflows` function is called on component mount."
          },
          {
            "id": 3,
            "title": "Integrate Container with Presentational Component",
            "description": "Connect the `WorkflowPageContainer` to the `WorkflowPage` component, passing the fetched data as props.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "In `src/components/workflows/WorkflowPageContainer.tsx`, import the `WorkflowPage` component created in the first subtask. In the `WorkflowPageContainer`'s return statement, render the `<WorkflowPage />` component, passing the `workflows` array from the `useWorkflowStore` state as a prop.",
            "status": "pending",
            "testStrategy": "Manually verify in a development environment that the container fetches data and the presentational component renders it."
          },
          {
            "id": 4,
            "title": "Update Next.js Route File to Use the Container",
            "description": "Refactor the main page file for the `/workflows` route to use the new container component.",
            "dependencies": [
              "4.3"
            ],
            "details": "Modify the file `src/app/(pages)/workflows/page.tsx`. Remove all existing logic (hooks, state management, and JSX). The file should now only import `WorkflowPageContainer` from `src/components/workflows/WorkflowPageContainer.tsx` and export it as the default component.",
            "status": "pending",
            "testStrategy": "Run the application and navigate to the `/workflows` page. Perform regression testing to ensure the page loads and displays the list of workflows exactly as it did before the refactor."
          },
          {
            "id": 5,
            "title": "Finalize Prop Types and Clean Up",
            "description": "Ensure strong typing and remove any redundant code or unused imports from the refactored files.",
            "dependencies": [
              "4.4"
            ],
            "details": "Review `WorkflowPage.tsx` and `WorkflowPageContainer.tsx`. Ensure the `TWorkflow` type is imported from `@/types/workflow` and used correctly in the props interface and state management. Verify that the old `src/app/(pages)/workflows/page.tsx` is clean and contains no leftover code or unused imports. This ensures the refactor is complete and maintainable.",
            "status": "pending",
            "testStrategy": "Run the TypeScript compiler (`tsc --noEmit`) to check for any type errors. Lint the modified files to ensure they adhere to project coding standards."
          }
        ]
      },
      {
        "id": 5,
        "title": "Refactor nodes-table.tsx using a Hook and Sub-components",
        "description": "`nodes-table.tsx` is a large component managing table state, data manipulation, and rendering. This task is to refactor it by extracting logic into a hook and creating smaller, reusable table components.",
        "details": "1. Create a custom hook `useNodesTable.ts` to manage all table state and logic: selection, pagination, search, filtering, and column visibility. 2. Create smaller, single-responsibility components like `NodesTableHeader.tsx`, `NodesTableRow.tsx`, and `NodesTablePagination.tsx`. 3. The `NodesTableRow` component will be responsible for rendering a single row, including badges, icons, and the dropdown menu. 4. Refactor `NodesTable` to be a presentational component that uses the `useNodesTable` hook and composes the smaller components (`NodesTableHeader`, `NodesTableRow`, etc.) to build the table.",
        "testStrategy": "Create comprehensive unit tests for the `useNodesTable` hook. Create Storybook stories or unit tests for the new sub-components (`NodesTableRow`, etc.) to test them in isolation. Update `NodesTable` tests to verify it correctly assembles the table from its new parts. Manually test all table interactions: sorting, filtering, pagination, selection, and column toggling.",
        "priority": "high",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useNodesTable` Hook to Encapsulate Table Logic",
            "description": "Create a new custom hook `useNodesTable.ts` in a new `src/hooks/` directory. This hook will abstract away the complexity of `useReactTable` and serve as the single source of truth for the table's state and interactions.",
            "dependencies": [],
            "details": "Migrate the `useReactTable` hook call and all related state management (`useState` for `sorting`, `columnFilters`, `columnVisibility`, `rowSelection`) from `src/components/nodes-table/nodes-table.tsx` into `src/hooks/use-nodes-table.ts`. The hook should accept `data` and `columns` as arguments and return the fully configured `table` instance provided by `useReactTable`.",
            "status": "pending",
            "testStrategy": "Create a new unit test file for `useNodesTable.ts`. Write tests to verify that the hook correctly initializes state, processes data, and returns a valid `table` instance. Test state changes like sorting and filtering."
          },
          {
            "id": 2,
            "title": "Create `NodesTableHeader` Component for Toolbar and Header",
            "description": "Create a new component `src/components/nodes-table/nodes-table-header.tsx` responsible for rendering the table's interactive toolbar (search, column visibility) and the static `<thead>` section.",
            "dependencies": [
              "5.1"
            ],
            "details": "This component will receive the `table` instance from the `useNodesTable` hook as a prop. It will render the search input and the column visibility `DropdownMenu`. It will also render the `<thead>` by mapping over `table.getHeaderGroups()`. All event handlers, such as the `onChange` for the search input, will call methods on the provided `table` instance (e.g., `table.getColumn('name')?.setFilterValue(...)`).",
            "status": "pending",
            "testStrategy": "Create a Storybook story or a unit test for `NodesTableHeader.tsx`. Mock the `table` instance and verify that the component renders correctly and that user interactions (like typing in the search box) call the appropriate methods on the mock `table` object."
          },
          {
            "id": 3,
            "title": "Create `NodesTableRow` Component for Single Row Rendering",
            "description": "Create a new component `src/components/nodes-table/nodes-table-row.tsx` to render a single row within the table body, encapsulating the layout and presentation of one node's data.",
            "dependencies": [
              "5.1"
            ],
            "details": "This component will receive a `row` object (from `table.getRowModel().rows`) as a prop. It will render a `TableRow` component containing all the cells for that row by mapping `row.getVisibleCells()` and using the `flexRender` utility. This isolates the responsibility of rendering a single node, including its selection checkbox, data fields, status badges, and the action menu as defined in `columns.ts`.",
            "status": "pending",
            "testStrategy": "Create a Storybook story for `NodesTableRow.tsx` that renders the component with different mock `row` objects to test various states (e.g., selected, different statuses)."
          },
          {
            "id": 4,
            "title": "Create `NodesTablePagination` Component for Pagination Controls",
            "description": "Create a new component `src/components/nodes-table/nodes-table-pagination.tsx` to handle the UI and logic for table pagination.",
            "dependencies": [
              "5.1"
            ],
            "details": "This component will receive the `table` instance as a prop. It will render the UI for navigating between pages (Previous/Next buttons) and displaying the selected row count. All actions will be handled by calling methods on the `table` instance (e.g., `table.nextPage()`, `table.getCanNextPage()`, `table.getState().rowSelection`).",
            "status": "pending",
            "testStrategy": "Create a Storybook story or unit test for `NodesTablePagination.tsx`. Mock the `table` instance with different pagination states (e.g., on the first page, on the last page) to verify that buttons are enabled/disabled correctly and that click events trigger the right methods."
          },
          {
            "id": 5,
            "title": "Refactor `nodes-table.tsx` to Use New Hook and Components",
            "description": "Refactor the main `nodes-table.tsx` component to be a clean, presentational component that composes the newly created hook and sub-components.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Modify `src/components/nodes-table/nodes-table.tsx`. Remove all local state management and complex rendering logic. Instead, call the `useNodesTable` hook to get the `table` instance. Use this instance to pass props to the new sub-components: `<NodesTableHeader table={table} />`, a `TableBody` that maps `table.getRowModel().rows` to `<NodesTableRow row={row} />` components, and `<NodesTablePagination table={table} />`. The component's primary role will be to assemble these pieces.",
            "status": "pending",
            "testStrategy": "Update the existing tests for `NodesTable.tsx` to ensure it correctly renders the new sub-components. Manually perform end-to-end testing on the table to verify that all functionality (sorting, filtering, selection, pagination) works as it did before the refactor."
          }
        ]
      },
      {
        "id": 6,
        "title": "Simplify workflow-list.tsx by Extracting Logic",
        "description": "`workflow-list.tsx` has too many responsibilities, including dialog state management, deletion logic, and navigation. This task is to extract this logic into a custom hook.",
        "details": "1. Create a custom hook `useWorkflowList.ts` in `src/hooks/`. 2. Move the logic for managing create, edit, and delete dialogs, the workflow deletion handler (`handleDeleteWorkflow`), and navigation logic (`useRouter`) into this hook. 3. Refactor `WorkflowList` to be a pure presentational component. It should call `useWorkflowList` and use the returned state and handlers to render the UI. 4. As per the recommendation, consider co-locating the dialog components with the components that trigger them. For example, the `CreateWorkflowDialog` could be managed within the component that contains the 'Create' button.",
        "testStrategy": "Create unit tests for the `useWorkflowList` hook to cover dialog management, deletion logic, and navigation calls. Update tests for `WorkflowList` to ensure it renders the correct UI based on the hook's state. Manually test the create, edit, and delete workflow user flows.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useWorkflowList.ts` and Move Core State and Navigation",
            "description": "Create the new hook file and move the foundational logic from `workflow-list.tsx`. This includes initializing `useRouter` for navigation, `useWorkflowStore` for data access, and the state for the currently selected workflow for editing or deletion.",
            "dependencies": [],
            "details": "Create a new file at `src/hooks/useWorkflowList.ts`. Move the `useRouter` and `useWorkflowStore` hook calls from `workflow-list.tsx` into this new hook. Also, move the `useState` calls for `workflowToEdit` and `workflowToDelete`. The hook should begin to take shape by returning the router instance, workflows from the store, and the selected workflow states.",
            "status": "pending",
            "testStrategy": "Create a test file `src/hooks/useWorkflowList.test.ts`. Write a basic test to ensure the hook initializes without errors and returns the expected initial state from the mocked `useWorkflowStore`."
          },
          {
            "id": 2,
            "title": "Migrate Dialog State and Handlers to `useWorkflowList` Hook",
            "description": "Move the state and handler functions for managing the create, edit, and delete dialogs from `workflow-list.tsx` into the `useWorkflowList` hook.",
            "dependencies": [
              "6.1"
            ],
            "details": "Relocate the `useState` variables (`isCreateDialogOpen`, `isEditDialogOpen`, `isDeleteDialogOpen`) and their corresponding open/close handler functions (e.g., `handleOpenCreateDialog`, `handleCloseCreateDialog`, `handleOpenDeleteDialog`, `handleSetWorkflowToDelete`) into the `useWorkflowList` hook. The hook should return the dialog open states and the handler functions to control them.",
            "status": "pending",
            "testStrategy": "In `useWorkflowList.test.ts`, add tests to verify that the dialog handler functions correctly update the dialog open states (e.g., calling `handleOpenCreateDialog` sets `isCreateDialogOpen` to true)."
          },
          {
            "id": 3,
            "title": "Encapsulate Workflow Deletion Logic in `useWorkflowList` Hook",
            "description": "Move the `handleDeleteWorkflow` function, which contains the logic for deleting a workflow via the store and managing dialog state, into the `useWorkflowList` hook.",
            "dependencies": [
              "6.2"
            ],
            "details": "Move the `handleDeleteWorkflow` function from `workflow-list.tsx` to `useWorkflowList.ts`. This function should call the `deleteWorkflow` action from the store using the `workflowToDelete` state and then call the handler to close the delete confirmation dialog. The hook will expose this `handleDeleteWorkflow` function.",
            "status": "pending",
            "testStrategy": "Add a test case for `handleDeleteWorkflow`. Mock the `useWorkflowStore`'s `deleteWorkflow` action and verify that it is called with the correct workflow ID. Also, assert that the delete dialog is closed after the deletion is handled."
          },
          {
            "id": 4,
            "title": "Refactor `WorkflowList` Component to Use the New Hook",
            "description": "Modify the `WorkflowList` component to remove all extracted logic and instead consume the `useWorkflowList` hook, transforming it into a presentational component.",
            "dependencies": [
              "6.3"
            ],
            "details": "In `src/app/workflows/workflow-list.tsx`, remove all the state variables and handler functions that were moved to the hook. Add a single call to `useWorkflowList()` at the top of the component. Destructure the returned state (e.g., `workflows`, `isDeleteDialogOpen`, `workflowToDelete`) and handlers (e.g., `handleOpenDeleteDialog`, `handleDeleteWorkflow`) and use them to connect the JSX elements and child components (`WorkflowTable`, dialogs).",
            "status": "pending",
            "testStrategy": "Update the tests for `WorkflowList`. Mock the `useWorkflowList` hook to provide different states (e.g., dialog open/closed) and assert that the component renders the correct UI and passes the correct props to its children."
          },
          {
            "id": 5,
            "title": "Co-locate Dialog Components with Their Triggers",
            "description": "As a final cleanup, move the rendering of the dialog components (`CreateWorkflowDialog`, `EditWorkflowDialog`, `DeleteWorkflowDialog`) from the main `WorkflowList` component to be closer to the components that trigger them, such as the `WorkflowTable`.",
            "dependencies": [
              "6.4"
            ],
            "details": "Currently, `WorkflowList` likely renders all dialogs at its top level. Refactor this by moving the `DeleteWorkflowDialog` and `EditWorkflowDialog` inside the `WorkflowTable` component. The `WorkflowList` will pass the necessary state and handlers from the hook down to `WorkflowTable` as props. The `CreateWorkflowDialog` can remain in `WorkflowList` next to the 'Create' button. This improves component encapsulation.",
            "status": "pending",
            "testStrategy": "Manually test the end-to-end user flow for creating, editing, and deleting a workflow to ensure that the dialogs open, function correctly, and close as expected after the refactoring."
          }
        ]
      },
      {
        "id": 7,
        "title": "Refactor workflow-table.tsx using a Hook and Sub-components",
        "description": "`workflow-table.tsx` is a 'god component' for displaying workflows. This task is to refactor it by extracting logic into a hook and creating smaller, reusable table components.",
        "details": "1. Create a custom hook `useWorkflowTable.ts` to manage all table state and logic: selection, pagination, search, filtering, and column visibility. 2. Create smaller, single-responsibility components like `WorkflowTableHeader.tsx`, `WorkflowTableRow.tsx`, and `WorkflowTablePagination.tsx`. 3. The `WorkflowTableRow` component will render a single row, including status badges and the actions dropdown menu. 4. Refactor `WorkflowTable` to be a presentational component that uses the `useWorkflowTable` hook and composes the smaller components to build the table structure.",
        "testStrategy": "Create unit tests for the new `useWorkflowTable` hook. Create Storybook stories or unit tests for the new sub-components (`WorkflowTableRow`, etc.). Update `WorkflowTable` tests to verify it correctly assembles the table. Manually test all table interactions: sorting, filtering, pagination, selection, and actions from the dropdown menu.",
        "priority": "high",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useWorkflowTable` Hook to Encapsulate Table Logic",
            "description": "Create a new custom hook to extract all state management and table logic from the `workflow-table.tsx` component. This is the foundational step for the refactor.",
            "dependencies": [],
            "details": "In a new file `src/hooks/use-workflow-table.ts`, create a hook named `useWorkflowTable`. This hook should accept `data: Workflow[]` and `columns: ColumnDef<Workflow>[]` as arguments. Move the `useState` calls for `sorting`, `columnFilters`, `columnVisibility`, and `rowSelection` from `workflow-table.tsx` into this hook. Also, move the `useReactTable` instance logic into the hook. The hook must return the `table` object provided by `@tanstack/react-table`.",
            "status": "pending",
            "testStrategy": "Create a new unit test file for `use-workflow-table.ts`. Write tests to verify that the hook correctly initializes the table state and that the returned `table` object is valid."
          },
          {
            "id": 2,
            "title": "Create `WorkflowTableToolbar` Component",
            "description": "Extract the toolbar section of the workflow table into its own dedicated component. This component will handle user interactions for filtering and column visibility.",
            "dependencies": [
              "7.1"
            ],
            "details": "Create a new file `src/app/(main)/workflows/components/workflow-table-toolbar.tsx`. This component will receive the `table` object (from the `useWorkflowTable` hook) as a prop. Move the JSX for the filter `Input` and the column visibility `DropdownMenu` from `workflow-table.tsx` into this new component. Wire up the `onChange` and `onCheckedChange` events to the appropriate methods on the `table` object (e.g., `table.getColumn('name')?.setFilterValue(...)`).",
            "status": "pending",
            "testStrategy": "Create a Storybook story or a unit test for `WorkflowTableToolbar.tsx`. Mock the `table` object and verify that interactions with the input and dropdown call the correct table methods."
          },
          {
            "id": 3,
            "title": "Create `WorkflowTablePagination` Component",
            "description": "Extract the pagination controls at the bottom of the table into a reusable component.",
            "dependencies": [
              "7.1"
            ],
            "details": "Create a new file `src/app/(main)/workflows/components/workflow-table-pagination.tsx`. This component will receive the `table` object as a prop. Move the JSX for the row selection count, and the 'Previous' and 'Next' buttons from `workflow-table.tsx`. The component will use methods and state from the `table` object, such as `table.previousPage()`, `table.getCanNextPage()`, and `table.getState().pagination`.",
            "status": "pending",
            "testStrategy": "Create a Storybook story or a unit test for `WorkflowTablePagination.tsx`. Mock the `table` object with different pagination states (e.g., first page, last page) and verify that buttons are enabled/disabled correctly and that click handlers call the right table methods."
          },
          {
            "id": 4,
            "title": "Create `WorkflowTableHeader` and `WorkflowTableRow` Components",
            "description": "Decompose the table's structure into separate components for the header and individual rows to improve readability and separation of concerns.",
            "dependencies": [
              "7.1"
            ],
            "details": "Create two new components in `src/app/(main)/workflows/components/`. First, `WorkflowTableHeader.tsx`, which will receive the `table` object and be responsible for rendering the `<thead>` by mapping over `table.getHeaderGroups()`. Second, `WorkflowTableRow.tsx`, which will receive a `row` object from `@tanstack/react-table` and render a single `<TableRow>` with its cells, using `flexRender` to display the content defined in `columns.tsx`.",
            "status": "pending",
            "testStrategy": "Create Storybook stories for `WorkflowTableHeader` and `WorkflowTableRow`. For `WorkflowTableRow`, pass a mock `row` object to ensure it renders all cells correctly, including any custom components like badges or action menus."
          },
          {
            "id": 5,
            "title": "Refactor `WorkflowTable` to Compose New Hook and Components",
            "description": "Reassemble the `workflow-table.tsx` component to act as a container that uses the new hook and composes the new sub-components.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "In `src/app/(main)/workflows/components/workflow-table.tsx`, remove all the extracted state and logic. Call the `useWorkflowTable` hook to get the `table` instance. Then, structure the component's return statement to render `<WorkflowTableToolbar />`, the main `<Table>` structure, and `<WorkflowTablePagination />`. Inside the `<Table>` tag, use `<WorkflowTableHeader />` for the header. For the `TableBody`, map over `table.getRowModel().rows` and render a `<WorkflowTableRow />` for each row.",
            "status": "pending",
            "testStrategy": "Update the existing tests for `WorkflowTable` to ensure it correctly renders the new child components. Manually test the entire table functionality—sorting, filtering, pagination, selection, and column visibility—to check for any regressions."
          }
        ]
      },
      {
        "id": 8,
        "title": "Refactor dashboard-controls.tsx for Clarity",
        "description": "`dashboard-controls.tsx` mixes demo/test logic for alerts and toasts with actual dashboard UI. This task is to separate these concerns into distinct components.",
        "details": "1. Remove the logic and UI for demonstrating alert dialogs and toast notifications. If this is needed for testing, move it to a Storybook story or a dedicated demo page. 2. Create a new component `DashboardMetrics.tsx` and move the metric display logic and UI into it. 3. Create a new component `QuickActions.tsx` and move the quick action buttons and their logic into it. 4. Simplify `DashboardControls.tsx` to be a layout container that renders the `DashboardMetrics` and `QuickActions` components.",
        "testStrategy": "Create unit/snapshot tests for the new `DashboardMetrics` and `QuickActions` components. Update tests for `DashboardControls` to ensure it correctly lays out its new child components. Manually verify the dashboard controls section looks and functions the same as before, minus the demo buttons.",
        "priority": "low",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `DashboardMetrics.tsx` and Extract Metric Cards",
            "description": "Create a new component file `src/pages/dashboard/components/DashboardMetrics.tsx`. Move the grid layout `div` and the four metric `Card` components from `dashboard-controls.tsx` into this new `DashboardMetrics` component.",
            "dependencies": [],
            "details": "Based on the analysis of `src/pages/dashboard/components/dashboard-controls.tsx`, the new file should contain the `<div className=\"grid gap-4 md:grid-cols-2 md:gap-8 lg:grid-cols-4\">` and all its children `Card` elements. Ensure all necessary imports (`Card`, `CardHeader`, `CardContent`, `CardTitle`, and `lucide-react` icons: `DollarSign`, `Users`, `CreditCard`, `Activity`) are also moved to the new file. The new component will be a self-contained unit for displaying dashboard metrics.",
            "status": "pending",
            "testStrategy": "Create a snapshot test for the new `DashboardMetrics` component to ensure it renders the four metric cards correctly."
          },
          {
            "id": 2,
            "title": "Create `QuickActions.tsx` and Extract Action Buttons",
            "description": "Create a new component file `src/pages/dashboard/components/QuickActions.tsx`. Create a new `QuickActions` component that contains the 'New Workflow' and 'Import Data' buttons, wrapped in a `div` that preserves their layout.",
            "dependencies": [],
            "details": "The new component should contain a `<div className=\"flex items-center pt-4 space-x-2\">` wrapper. Move the `<Button>New Workflow</Button>` and `<Button variant=\"outline\">Import Data</Button>` from `dashboard-controls.tsx` into this `div`. Add the required `Button` import from `@/components/ui/button`. This component will be responsible for rendering the main user action buttons.",
            "status": "pending",
            "testStrategy": "Create a snapshot test for the new `QuickActions` component to verify it renders the two action buttons correctly."
          },
          {
            "id": 3,
            "title": "Remove Extracted UI Elements from `dashboard-controls.tsx`",
            "description": "Edit `src/pages/dashboard/components/dashboard-controls.tsx` to remove the UI elements that were extracted into `DashboardMetrics` and `QuickActions` in the previous subtasks.",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "This is a cleanup step. Delete the entire `<div className=\"grid ...\">` block containing the metric cards. From the `<div className=\"flex ...\">` container, delete only the 'New Workflow' and 'Import Data' `Button` components. After this step, the `dashboard-controls.tsx` file will temporarily only contain the demo/test UI for alerts and toasts.",
            "status": "pending",
            "testStrategy": "No specific tests needed for this intermediate refactoring step. Manual verification that the application still runs is sufficient."
          },
          {
            "id": 4,
            "title": "Remove Demo Logic for Alerts and Toasts from `dashboard-controls.tsx`",
            "description": "Purge all demonstration and testing logic from `dashboard-controls.tsx`. This includes the `AlertDialog` component, the 'Show Toast' button, and the `useToast` hook.",
            "dependencies": [
              "8.3"
            ],
            "details": "Remove the entire remaining `<div className=\"flex ...\">` which now only contains the demo buttons. Also, remove the `useToast` hook call and all now-unused imports, such as `AlertDialog`, its sub-components, and `useToast`. The component function body should be nearly empty after this step, returning only an empty fragment.",
            "status": "pending",
            "testStrategy": "Manual verification that the demo buttons no longer appear on the dashboard page."
          },
          {
            "id": 5,
            "title": "Recompose `DashboardControls.tsx` with New Components",
            "description": "Finalize the refactoring of `dashboard-controls.tsx` by turning it into a clean layout container. Import and render the `DashboardMetrics` and `QuickActions` components.",
            "dependencies": [
              "8.1",
              "8.2",
              "8.4"
            ],
            "details": "Modify the now-clean `DashboardControls.tsx` to import `DashboardMetrics` from `./DashboardMetrics` and `QuickActions` from `./QuickActions`. The component's return statement should render `<DashboardMetrics />` and `<QuickActions />` inside the root `React.Fragment`. This restores the complete UI (minus the demo buttons) in a more organized, component-based structure.",
            "status": "pending",
            "testStrategy": "Update the snapshot test for `DashboardControls` to reflect its new structure. Manually verify the dashboard controls section in the UI looks and functions the same as before the refactor, but without the demo buttons."
          }
        ]
      },
      {
        "id": 9,
        "title": "Decompose NavBar.tsx into Smaller Components",
        "description": "`NavBar.tsx` is a large component handling the logo, desktop navigation, and mobile menu logic and state. This task is to break it down into smaller, more focused components.",
        "details": "1. Create separate components: `Logo.tsx`, `DesktopNav.tsx`, and `MobileMenu.tsx` in `src/components/global/`. 2. The `MobileMenu` component can be further broken down if complex (e.g., `MobileMenuToggle`, `MobileMenuOverlay`). 3. Isolate the mobile menu's open/closed state. This can be done with a local `useState` inside the `NavBar` or a more global solution like a Zustand store if the state is needed elsewhere. 4. Refactor `NavBar.tsx` to be a clean container that imports and renders `Logo`, `DesktopNav`, and `MobileMenu`, passing any necessary props.",
        "testStrategy": "Create snapshot tests for the new `Logo`, `DesktopNav`, and `MobileMenu` components. Test the state management for the mobile menu, ensuring the toggle button correctly opens and closes it. Perform manual regression testing on various screen sizes to ensure both desktop and mobile navigation work correctly.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create the `Logo.tsx` Component",
            "description": "Extract the logo and brand name rendering from `NavBar.tsx` into a new, self-contained `Logo.tsx` component to promote reusability and separation of concerns.",
            "dependencies": [],
            "details": "Create a new file at `src/components/global/Logo.tsx`. Identify the JSX in `NavBar.tsx` that renders the site logo (likely an `Image` component) and brand name, wrapped in a `Link` component pointing to the homepage. Move this entire block into the new `Logo.tsx` component and export it.",
            "status": "pending",
            "testStrategy": "Create a snapshot test for the `Logo.tsx` component to ensure it renders the link and image correctly."
          },
          {
            "id": 2,
            "title": "Create the `DesktopNav.tsx` Component",
            "description": "Extract the list of navigation links intended for desktop view from `NavBar.tsx` into a dedicated `DesktopNav.tsx` component.",
            "dependencies": [],
            "details": "Create a new file at `src/components/global/DesktopNav.tsx`. Locate the `<ul>` or `<nav>` element in `NavBar.tsx` that contains the main navigation links and is typically hidden on mobile (e.g., using a class like `hidden md:flex`). Move this structure, along with any associated data array for the links, into the new `DesktopNav.tsx` component.",
            "status": "pending",
            "testStrategy": "Create a snapshot test for `DesktopNav.tsx` to verify it renders the list of navigation links."
          },
          {
            "id": 3,
            "title": "Create Mobile Menu Components (`MobileMenuToggle` and `MobileMenu`)",
            "description": "Decompose the mobile menu functionality into two separate components: `MobileMenuToggle.tsx` for the button and `MobileMenu.tsx` for the menu panel itself.",
            "dependencies": [],
            "details": "1. Create `src/components/global/MobileMenuToggle.tsx` for the hamburger/close icon button. This component will receive `isOpen` and `onClick` props. 2. Create `src/components/global/MobileMenu.tsx` for the full-screen overlay and the navigation links within it. This component will receive an `isOpen` prop to control its visibility and a function prop (e.g., `onClose`) to handle closing the menu when a link is clicked.",
            "status": "pending",
            "testStrategy": "Create snapshot tests for both `MobileMenuToggle.tsx` (in open and closed states) and `MobileMenu.tsx` (in open and closed states)."
          },
          {
            "id": 4,
            "title": "Refactor `NavBar.tsx` to Compose New Components and Manage State",
            "description": "Rebuild `NavBar.tsx` to be a clean container that imports and arranges the new `Logo`, `DesktopNav`, and mobile menu components, while initially managing the mobile menu's state.",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3"
            ],
            "details": "Remove the now-extracted JSX from `NavBar.tsx`. Import `Logo`, `DesktopNav`, `MobileMenuToggle`, and `MobileMenu`. Implement a `useState` hook within `NavBar.tsx` to manage the `isMenuOpen` state. Render the new components in the correct layout, passing the state and toggle function as props to `MobileMenuToggle` and `MobileMenu`.",
            "status": "pending",
            "testStrategy": "Update the snapshot test for `NavBar.tsx` to reflect its new, simpler structure. Manually test on different screen sizes to ensure the desktop nav, logo, and mobile menu toggle are correctly displayed and that the mobile menu opens and closes as expected."
          },
          {
            "id": 5,
            "title": "Isolate Mobile Menu State with a `useMobileMenu` Hook",
            "description": "Abstract the state and logic for managing the mobile menu's open/closed status from `NavBar.tsx` into a reusable custom hook to further simplify the `NavBar` component.",
            "dependencies": [
              "9.4"
            ],
            "details": "Create a new file, for example `src/hooks/useMobileMenu.ts`. Define a `useMobileMenu` hook that encapsulates the `useState` for the menu's visibility and returns the state (`isOpen`) and a toggle function (`toggleMenu`). Refactor `NavBar.tsx` to use this new hook, removing the local `useState` and its related logic.",
            "status": "pending",
            "testStrategy": "Create a unit test for the `useMobileMenu` hook using `@testing-library/react-hooks` to verify that it correctly initializes state and that the toggle function updates the state. Ensure `NavBar` continues to function correctly after refactoring to use the hook."
          }
        ]
      },
      {
        "id": 10,
        "title": "Simplify node-edit-dialog.tsx with a Custom Hook",
        "description": "`node-edit-dialog.tsx` is a complex component managing dialog state, node data, tabs, and layout. This task is to extract its logic into a custom hook.",
        "details": "1. Create a custom hook `useNodeEditDialog.ts` in `src/hooks/`. 2. Move the logic for managing dialog open/closed state, the state of the node data being edited, active tab state, and any other UI state into this hook. 3. The hook should return the managed state and event handlers. 4. Refactor `NodeEditDialog` to be a pure presentational component. It should call `useNodeEditDialog` and use the returned values to render the dialog layout, resizable panels, and child components (`InputSection`, `OutputSection`, etc.).",
        "testStrategy": "Create unit tests for the `useNodeEditDialog` hook to verify state management for tabs and node data. Update tests for `NodeEditDialog` to ensure it renders the correct UI based on the hook's state. Manually test the entire node editing flow within the dialog.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useNodeEditDialog` Hook and Migrate Core State",
            "description": "Create the new custom hook file and move the fundamental state management logic from `NodeEditDialog` into it. This sets up the foundation for the rest of the refactoring.",
            "dependencies": [],
            "details": "1. Create a new file at `src/hooks/useNodeEditDialog.ts`. 2. Define and export a `useNodeEditDialog` function that accepts props, likely including `nodeId`. 3. Move the `useState` calls for the edited node data (`nodeData`), the active tab (`activeTab`), and the resizable panel layout (`panelLayout`) from `src/components/workflow/node-edit-dialog.tsx` into this new hook. 4. The hook should initially return these state variables.",
            "status": "pending",
            "testStrategy": "Create a basic unit test for the hook that verifies the initial state values are set correctly."
          },
          {
            "id": 2,
            "title": "Migrate Data Loading and Store Interaction Logic",
            "description": "Move the effects and store interactions responsible for fetching and initializing the node data into the `useNodeEditDialog` hook.",
            "dependencies": [
              "10.1"
            ],
            "details": "1. In `useNodeEditDialog.ts`, import `useWorkflowStore`. 2. Move the `useEffect` from `node-edit-dialog.tsx` that finds and sets the node data from the workflow store based on the `nodeId` prop. 3. Ensure the hook correctly handles cases where the `nodeId` is null or the node is not found. 4. The hook should now manage the lifecycle of `nodeData`, keeping it synchronized with the store and the provided `nodeId`.",
            "status": "pending",
            "testStrategy": "Write a unit test for the hook that mocks `useWorkflowStore` and asserts that `nodeData` is correctly populated when `nodeId` changes."
          },
          {
            "id": 3,
            "title": "Implement Event Handlers and State Updaters in the Hook",
            "description": "Move all event handling logic, such as saving data, changing tabs, and updating the node's state, into the `useNodeEditDialog` hook.",
            "dependencies": [
              "10.2"
            ],
            "details": "1. In `useNodeEditDialog.ts`, create and export handlers for UI interactions. 2. Move the `handleTabChange` logic to update the `activeTab` state. 3. Move the `onLayout` handler for the `ResizablePanelGroup`. 4. Create a generic `updateNodeData` function that can update fields on the `nodeData` state object. 5. Implement the `handleSave` function within the hook, which will use the `updateNode` action from `useWorkflowStore` to persist the changes. 6. Return all state variables and these new handlers from the hook.",
            "status": "pending",
            "testStrategy": "Unit test the handlers. For `handleSave`, mock the store's `updateNode` function and verify it's called with the correct data. For `updateNodeData`, verify that the internal `nodeData` state is updated correctly."
          },
          {
            "id": 4,
            "title": "Refactor `NodeEditDialog` to be a Presentational Component",
            "description": "Rewrite the `NodeEditDialog` component to remove all internal logic and instead consume the `useNodeEditDialog` hook, making it a pure presentational component.",
            "dependencies": [
              "10.3"
            ],
            "details": "1. In `src/components/workflow/node-edit-dialog.tsx`, remove all `useState`, `useEffect`, and handler function definitions. 2. Call the `useNodeEditDialog` hook at the top of the component, passing the required props (e.g., `nodeId`). 3. Destructure the state and handlers from the hook's return value (e.g., `{ nodeData, activeTab, handleTabChange, handleSave, updateNodeData, ... }`). 4. Connect the JSX to the values from the hook. For example, set `<Tabs value={activeTab} onValueChange={handleTabChange}>` and `<DialogFooter><Button onClick={handleSave}>Save</Button></DialogFooter>`.",
            "status": "pending",
            "testStrategy": "Update the component snapshot tests for `NodeEditDialog` to reflect the new structure. Manually verify in the browser that the dialog still renders correctly with data from the hook."
          },
          {
            "id": 5,
            "title": "Update Child Section Components and Finalize Integration",
            "description": "Ensure that the child components within the dialog (`InputSection`, `OutputSection`, etc.) receive the correct props from the refactored `NodeEditDialog` parent.",
            "dependencies": [
              "10.4"
            ],
            "details": "1. Review the props required by `InputSection`, `OutputSection`, `GeneralSection`, and `LogsSection`. They likely expect `node` data and an `onChange` or `onUpdate` handler. 2. In `node-edit-dialog.tsx`, ensure you are passing the `nodeData` state and the `updateNodeData` handler from the hook down to these child components. 3. Adjust the prop names or values as needed to match the child components' expectations. For example: `<InputSection node={nodeData} onUpdate={updateNodeData} />`. 4. This step ensures the data flow from the hook, through the parent, and down to the children is complete and functional.",
            "status": "pending",
            "testStrategy": "Manually test the full functionality of the node edit dialog. Verify that making changes in the `InputSection` or `GeneralSection` updates the state and that clicking 'Save' persists the changes correctly."
          }
        ]
      },
      {
        "id": 11,
        "title": "Refactor workflow-layout.tsx by Extracting Logic",
        "description": "`workflow-layout.tsx` is responsible for managing layout state, handling user interactions, and rendering the UI. This task is to extract the logic into a custom hook.",
        "details": "1. Create a custom hook `useWorkflowLayout.ts` in `src/hooks/`. 2. Encapsulate all state management logic within this hook, including sidebar state, selected nodes, search term, filters, line type, and minimap visibility. 3. Move all event handlers for user interactions (e.g., run/stop workflow, node selection) into the hook. 4. Refactor `WorkflowLayout` to be a pure presentational component that calls `useWorkflowLayout` and uses the returned state and handlers to render the sidebar, header, and canvas areas.",
        "testStrategy": "Create unit tests for the `useWorkflowLayout` hook to verify state transitions and handler logic. Update tests for `WorkflowLayout` to check that it renders the correct layout based on the state provided by the hook. Manually test all layout interactions to ensure no regressions.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useWorkflowLayout.ts` and Migrate State Declarations",
            "description": "Create the new custom hook file and move all state management declarations from `workflow-layout.tsx` into it. This will be the foundation for centralizing the component's logic.",
            "dependencies": [],
            "details": "In the `src/hooks/` directory, create a new file named `useWorkflowLayout.ts`. Cut all `useState` and `useAtom` hooks from `src/app/workflows/[workflowId]/workflow-layout.tsx` and paste them inside the new `useWorkflowLayout` function. This includes state for `isSidebarOpen`, `selectedNode`, `searchTerm`, `filters`, `lineType`, `isMinimapVisible`, `isRunning`, and `runStatus`.",
            "status": "pending",
            "testStrategy": "No specific tests for this subtask, but it's a prerequisite for the following steps. Ensure the file is created and the state declarations are moved without syntax errors."
          },
          {
            "id": 2,
            "title": "Move Event Handlers and Effects into `useWorkflowLayout` Hook",
            "description": "Relocate all event handler functions and associated `useEffect` hooks from `workflow-layout.tsx` to the new `useWorkflowLayout.ts` hook.",
            "dependencies": [
              "11.1"
            ],
            "details": "Move the functions `handleNodeSelect`, `handleSearchChange`, `handleFilterChange`, `handleRunWorkflow`, `handleStopWorkflow`, and `handleClearSelection` into the `useWorkflowLayout` hook. Also, move any `useEffect` hooks, particularly the one responsible for the workflow run simulation. Ensure these functions now correctly reference the state variables that are local to the hook.",
            "status": "pending",
            "testStrategy": "Begin creating unit tests for the `useWorkflowLayout` hook. Write initial tests to verify that calling these handlers correctly updates the internal state of the hook (e.g., calling `handleRunWorkflow` sets `isRunning` to true)."
          },
          {
            "id": 3,
            "title": "Define and Return the Hook's Public API",
            "description": "Structure the `useWorkflowLayout` hook to return a single, comprehensive object containing all the state values and handler functions required by the UI.",
            "dependencies": [
              "11.2"
            ],
            "details": "At the end of the `useWorkflowLayout` function, add a `return` statement. The returned object should expose all state and handlers needed by the view layer, such as: `isSidebarOpen`, `setSidebarOpen`, `selectedNode`, `searchTerm`, `filters`, `lineType`, `isMinimapVisible`, `isRunning`, `runStatus`, `handleNodeSelect`, `handleSearchChange`, `handleFilterChange`, `handleRunWorkflow`, `handleStopWorkflow`, `handleClearSelection`, `setLineType`, and `setMinimapVisible`.",
            "status": "pending",
            "testStrategy": "Expand the unit tests for `useWorkflowLayout` to assert that the returned object has the correct shape and that the initial state values are as expected."
          },
          {
            "id": 4,
            "title": "Refactor `WorkflowLayout` to Consume the `useWorkflowLayout` Hook",
            "description": "Modify `workflow-layout.tsx` to remove all the now-extracted logic and state, and instead, consume the new `useWorkflowLayout` hook to become a presentational component.",
            "dependencies": [
              "11.3"
            ],
            "details": "In `src/app/workflows/[workflowId]/workflow-layout.tsx`, delete all the `useState`, `useAtom`, `useEffect`, and event handler functions that were moved. At the top of the `WorkflowLayout` component, add a single call: `const { ... } = useWorkflowLayout();`. Destructure all the necessary state and handlers from the hook's return value.",
            "status": "pending",
            "testStrategy": "Update or create snapshot tests for `WorkflowLayout` to ensure it renders correctly with mock data provided by a mocked version of the `useWorkflowLayout` hook. This verifies its role as a presentational component."
          },
          {
            "id": 5,
            "title": "Update Prop Drilling to Child Components",
            "description": "Verify and update the props being passed down to child components (`WorkflowHeader`, `WorkflowSidebar`, `WorkflowCanvas`) to ensure they are correctly wired to the values returned by the `useWorkflowLayout` hook.",
            "dependencies": [
              "11.4"
            ],
            "details": "In the JSX of `workflow-layout.tsx`, review the props passed to each child component. For example, ensure `WorkflowHeader` receives `isRunning={isRunning}`, `onRun={handleRunWorkflow}`, and `onStop={handleStopWorkflow}` from the hook. Similarly, check that `WorkflowSidebar` and `WorkflowCanvas` receive their respective props (`selectedNode`, `onNodeSelect`, etc.) from the hook's destructured values.",
            "status": "pending",
            "testStrategy": "Perform manual end-to-end testing of the workflow layout page. Verify all interactions: running/stopping the workflow, selecting nodes, using search and filters, changing line type, and toggling the minimap to ensure no regressions occurred during the refactor."
          }
        ]
      },
      {
        "id": 12,
        "title": "Simplify create-node-page.tsx with a Custom Hook",
        "description": "`create-node-page.tsx` handles form state, submission, UI state, and rendering. This task is to extract the complex logic into a dedicated hook.",
        "details": "1. Create a custom hook `useCreateNodePage.ts` in `src/hooks/`. 2. Move all logic into this hook: `react-hook-form` setup and state, form submission handler (including API calls for creating the node and form config), and UI state management (logo preview, preview dialog). 3. The hook should return the form methods, handlers, and UI state needed by the component. 4. Refactor `CreateNodePage` to be a pure presentational component that calls `useCreateNodePage` and renders the form UI using the values from the hook.",
        "testStrategy": "Create unit tests for the `useCreateNodePage` hook, mocking API calls to verify form submission logic. Update tests for `CreateNodePage` to ensure it renders the form correctly. Manually test the end-to-end flow of creating a new node.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useCreateNodePage.ts` and Move Initial State and Hooks",
            "description": "Create the new hook file and move the basic state management and hook initializations from `create-node-page.tsx` into it.",
            "dependencies": [],
            "details": "Create a new file at `src/hooks/useCreateNodePage.ts`. Define and export a function `useCreateNodePage`. Move the `useState` calls for `logoPreview`, `isPreviewOpen`, and `formConfig` from `CreateNodePage` into this new hook. Also, move the initializations of `useRouter`, `useNodesStore`, and `useUIStore` into the hook.",
            "status": "pending",
            "testStrategy": "Verify the new hook file is created and the specified state and hook initializations are moved from the component."
          },
          {
            "id": 2,
            "title": "Migrate Form Schema and `react-hook-form` Setup to the Hook",
            "description": "Move the Zod schema and the `useForm` hook setup into `useCreateNodePage.ts` to encapsulate all form-related logic.",
            "dependencies": [
              "12.1"
            ],
            "details": "Move the `formSchema` (Zod schema) definition into `useCreateNodePage.ts`. Relocate the `useForm` hook call, including its configuration with `zodResolver` and `defaultValues`, from `CreateNodePage` to the `useCreateNodePage` hook. The hook should begin to take shape by returning the `form` object.",
            "status": "pending",
            "testStrategy": "Ensure the `useForm` instance is correctly initialized within the hook. The hook should return the form methods."
          },
          {
            "id": 3,
            "title": "Move Data Fetching and Form Submission Logic to the Hook",
            "description": "Transfer the logic for fetching the form configuration and handling the form submission, including API calls, into the `useCreateNodePage` hook.",
            "dependencies": [
              "12.2"
            ],
            "details": "Move the `useEffect` responsible for fetching `formConfig.json` into the hook. Also, move the entire `onSubmit` function, which includes the `axios.post` call to create the node, the `addNode` store action, `showSnackbar` calls for success/error handling, and the `router.push` navigation logic.",
            "status": "pending",
            "testStrategy": "Unit test the `onSubmit` handler within the hook by mocking `axios`, `useNodesStore`, `useUIStore`, and `useRouter` to verify the correct calls are made on success and error."
          },
          {
            "id": 4,
            "title": "Move UI Event Handlers and Finalize Hook's Return Signature",
            "description": "Move the remaining UI-specific event handlers into the hook and define the final return object that will be provided to the component.",
            "dependencies": [
              "12.3"
            ],
            "details": "Move the `handleFileChange` logic for the logo preview and the state setters for the preview dialog (`setIsPreviewOpen`) into the hook. Finalize the hook's return signature. It must return all necessary state and handlers for the component: `form`, `onSubmit`, `handleFileChange`, `logoPreview`, `isPreviewOpen`, `setIsPreviewOpen`, and `formConfig`.",
            "status": "pending",
            "testStrategy": "Verify that the hook returns all the required state and handlers with the correct types."
          },
          {
            "id": 5,
            "title": "Refactor `CreateNodePage` to a Presentational Component",
            "description": "Rewrite the `CreateNodePage` component to be a pure presentational component that consumes the `useCreateNodePage` hook.",
            "dependencies": [
              "12.4"
            ],
            "details": "Remove all logic (state, effects, handlers) that was moved to the `useCreateNodePage` hook from `src/pages/create-node-page.tsx`. Call the `useCreateNodePage()` hook at the top of the component and destructure the returned values. Update the JSX to use the state and handlers provided by the hook, making the component solely responsible for rendering the UI.",
            "status": "pending",
            "testStrategy": "Update component tests to mock the `useCreateNodePage` hook and verify that the component renders correctly based on the mocked return values. Manually test the end-to-end flow of creating a node to ensure the refactoring didn't introduce regressions."
          }
        ]
      },
      {
        "id": 13,
        "title": "Simplify edit-node-page.tsx with a Custom Hook",
        "description": "`edit-node-page.tsx` is responsible for data fetching, form state, submission, UI state, and rendering. This task is to extract this logic into a hook.",
        "details": "1. Create a custom hook `useEditNodePage.ts` in `src/hooks/`. 2. Move all logic into this hook: data fetching for the node, form state management, form submission handler (for updating the node), and UI state management (logo preview, loading/error states). 3. The hook should return the form data, handlers, and UI state. 4. Refactor `EditNodePage` to be a pure presentational component that calls `useEditNodePage` and renders the form UI based on the hook's return values.",
        "testStrategy": "Create unit tests for the `useEditNodePage` hook, mocking API calls for data fetching and form submission. Update tests for `EditNodePage` to ensure it renders loading, error, and success states correctly. Manually test the end-to-end flow of editing an existing node.",
        "priority": "medium",
        "dependencies": [],
        "status": "todo",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `useEditNodePage.ts` and Move Initial Data Fetching Logic",
            "description": "Create the new hook file in `src/hooks/` and move the logic responsible for fetching the node's initial data from `edit-node-page.tsx`.",
            "dependencies": [],
            "details": "Create the file `src/hooks/useEditNodePage.ts`. Define a `useEditNodePage` function that accepts the node `id` from the URL. Move the logic using `useRouter`, `useNodesStore` (`getNodeById`), and the `useEffect` for fetching data into this hook. Also, move the `isLoading` state management for this initial fetch. The hook should return the fetched `node` data, `isLoading`, and any potential `error` state.",
            "status": "pending",
            "testStrategy": "Create a unit test for the hook that mocks `useRouter` and `useNodesStore` to verify that it calls `getNodeById` with the correct ID and returns the correct loading and data states."
          },
          {
            "id": 2,
            "title": "Move Form State Management into `useEditNodePage` Hook",
            "description": "Relocate the `react-hook-form` setup and initialization from the component to the custom hook.",
            "dependencies": [
              "13.1"
            ],
            "details": "Move the `useForm` call from `edit-node-page.tsx` into the `useEditNodePage` hook. In the data-fetching `useEffect`, use the `reset` method from `useForm` to populate the form fields with the fetched node data. The hook should return all necessary form methods and state: `register`, `handleSubmit`, `control`, `setValue`, and `formState: { errors }`.",
            "status": "pending",
            "testStrategy": "Extend the unit test for the hook to verify that `reset` is called with the fetched node data. Mock the `useForm` return values to test the integration."
          },
          {
            "id": 3,
            "title": "Move Form Submission Logic into `useEditNodePage` Hook",
            "description": "Transfer the `onSubmit` function, which contains the node update logic, from the component into the custom hook.",
            "dependencies": [
              "13.2"
            ],
            "details": "Move the `onSubmit` function from `edit-node-page.tsx` to `useEditNodePage.ts`. This function is responsible for preparing the form data (including base64 conversion for the logo) and calling the `updateNode` action from `useNodesStore`. The hook should manage the submission's loading state (e.g., `isSubmitting`) and return the `onSubmit` handler.",
            "status": "pending",
            "testStrategy": "Add a test case to the hook's unit test to simulate a form submission. Verify that the `onSubmit` handler correctly processes the data and calls the `updateNode` action with the expected payload."
          },
          {
            "id": 4,
            "title": "Move Logo Preview State and Handler into `useEditNodePage` Hook",
            "description": "Encapsulate the state and logic for handling the logo file input and preview within the `useEditNodePage` hook.",
            "dependencies": [
              "13.1"
            ],
            "details": "Move the `logoPreview` state (`useState`) and the `handleFileChange` function into the `useEditNodePage` hook. The data-fetching `useEffect` should also be updated to set the initial `logoPreview` from the fetched node's `logo` field. The hook must return the `logoPreview` state and the `handleFileChange` handler.",
            "status": "pending",
            "testStrategy": "Unit test the `handleFileChange` logic within the hook by mocking the `FileReader` API to ensure it correctly updates the `logoPreview` state."
          },
          {
            "id": 5,
            "title": "Refactor `EditNodePage` to Use the `useEditNodePage` Hook",
            "description": "Simplify the `EditNodePage` component by removing all extracted logic and having it consume the new `useEditNodePage` hook, making it a presentational component.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "In `src/pages/nodes/[id]/edit-node-page.tsx`, remove all state, effects, and handlers that were moved to the hook. Call `useEditNodePage(id)` at the top of the component to get all necessary data, state, and handlers. The component should then render the UI (e.g., `PageLayout`, `NodeForm`) by passing the props received from the hook. Ensure the component correctly handles the `isLoading` and `error` states.",
            "status": "pending",
            "testStrategy": "Update the component test for `EditNodePage` to mock the `useEditNodePage` hook. Test that the component renders the loading state, error state, and the `NodeForm` with the correct props based on the mocked hook's return values."
          }
        ]
      },
      {
        "id": 14,
        "title": "Move Utility Files from `src/utils` to `src/lib`",
        "description": "As part of the utility consolidation initiative, move all files and subdirectories from the `src/utils/` directory into the `src/lib/` directory.",
        "details": "Physically move all contents of `src/utils` into `src/lib`. If there are any naming conflicts, they must be resolved. The directory structure within `src/lib` should be reviewed and organized logically after the move, for example, creating subdirectories like `src/lib/api/` or `src/lib/performance/` if they don't exist and are needed.",
        "testStrategy": "Verify that all files from `src/utils` are now present in `src/lib`. The project is not expected to build successfully at this stage, as import paths will be broken.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Update All Import Paths from `src/utils` to `src/lib`",
        "description": "Update all import statements across the entire application to reflect the new location of utility files in `src/lib/`.",
        "details": "Perform a global search for imports pointing to `src/utils/` or any of its subdirectories. Update these paths to point to the new location within `src/lib/`. Also, check and update any path aliases in `tsconfig.json` or `jsconfig.json` that may reference the old `utils` directory.",
        "testStrategy": "Run a static analysis tool or global search to ensure no references to `src/utils/` remain. The application should compile and build successfully without errors related to these modules.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Delete `src/utils` Directory and Verify Functionality",
        "description": "Delete the now-empty `src/utils/` directory and perform a full regression test to ensure the application remains stable.",
        "details": "After all files have been moved and import paths updated, delete the `src/utils/` directory from the codebase. Run the full test suite and perform manual smoke testing on key features that relied on the moved utilities to ensure no functionality has been broken.",
        "testStrategy": "Confirm the `src/utils/` directory is deleted. Run `npm run build` or equivalent to ensure a successful production build. Manually test critical application workflows.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Consolidate Mock Data from `src/dummy` into `src/data`",
        "description": "Unify all mock, sample, and dummy data by moving all files and subdirectories from `src/dummy/` into the `src/data/` directory.",
        "details": "Move all contents of `src/dummy/` into `src/data/`. Review the folder structure within `src/data/` after the move and organize it logically if needed. This centralizes all non-production data in one canonical location.",
        "testStrategy": "Verify that all files and folders from `src/dummy` are now located inside `src/data`. The application will likely have broken imports at this stage.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Update Mock Data Imports and Delete `src/dummy` Directory",
        "description": "Update all import paths that reference `src/dummy/` to point to `src/data/`, then delete the old directory.",
        "details": "Search the codebase for any imports from `src/dummy/` and update them to the new paths within `src/data/`. Once all imports are fixed, delete the empty `src/dummy/` directory. Verify that all parts of the application that use this mock data still function as expected.",
        "testStrategy": "Run a global search to ensure no references to `src/dummy/` remain. Manually navigate to pages or trigger UI states that rely on this mock data to ensure they render correctly. The application must build successfully.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Colocate Page Logic from `src/components/pages` into `src/app` Routes",
        "description": "Merge the content of page components from `src/components/pages/` directly into their corresponding `page.tsx` files within the `src/app/` directory.",
        "details": "For each file in `src/components/pages/` (e.g., `nodes-page.tsx`), copy its contents into the corresponding Next.js route file (e.g., `src/app/nodes/page.tsx`). The route file should now contain the full page logic, not just an import. All relative import paths within the moved code must be adjusted to their new location.",
        "testStrategy": "After migrating a page, navigate to its route in the browser to ensure it renders correctly. Check the browser console for any errors. Repeat for all migrated pages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Delete `src/components/pages` Directory and Test All Routes",
        "description": "After all page components have been migrated into `src/app`, delete the `src/components/pages` directory and perform a full routing test.",
        "details": "Ensure the `src/components/pages` directory is empty before deleting it. Conduct a thorough test of every application route to confirm that all pages render correctly and that their functionality is intact. This includes checking for broken links or navigation issues.",
        "testStrategy": "Verify the deletion of the `src/components/pages` directory. Create a test plan to click through every link and visit every URL in the application, ensuring no 404s or rendering errors occur.",
        "priority": "high",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Colocate Type Definitions for FormBuilder Feature",
        "description": "Move `FormBuilder`-related types from the global `src/types/` directory to a local `types.ts` file within the FormBuilder component's directory.",
        "details": "Identify all type definitions in `src/types/` that are exclusively used by the FormBuilder feature. Create a new file, e.g., `src/components/FormBuilder/types.ts`. Move the relevant types into this new file. Update all imports within the FormBuilder feature to use the new local types file.",
        "testStrategy": "Run the TypeScript compiler (`tsc --noEmit`) to ensure there are no type errors. Verify that all components related to FormBuilder still function correctly and have proper type inference in the IDE.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Colocate Type Definitions for Workflow Feature",
        "description": "Move `workflow`-related types from the global `src/types/` directory to a local `types.ts` file within the workflow feature's directory.",
        "details": "Identify all type definitions in `src/types/` that are exclusively used by the workflow module/components. Create a new local `types.ts` file within the primary workflow directory. Move the relevant types into this new file and update all imports within the workflow feature to use the new local types file.",
        "testStrategy": "Run the TypeScript compiler (`tsc --noEmit`) to ensure type safety is maintained. Check the parts of the application that use the workflow feature to ensure they operate without any new bugs.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Consolidate Remaining Global Types and Clean Up `src/types`",
        "description": "After collocating feature-specific types, move any remaining truly global types into a single `src/types/index.ts` file and remove the now-empty subdirectories.",
        "details": "Review the `src/types/` directory. Any types that are genuinely used across multiple, unrelated features should be considered global. Consolidate these into a single `src/types/index.ts` file. All other files and subdirectories within `src/types/` should now be empty and can be deleted.",
        "testStrategy": "Run `tsc --noEmit` to ensure the final type structure is valid. A full build and application smoke test should be performed to catch any regressions from the type refactoring.",
        "priority": "low",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-04T07:18:23.495Z",
      "updated": "2025-10-04T08:06:54.466Z",
      "description": "Tasks for master context"
    }
  }
}